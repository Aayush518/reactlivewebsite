"use strict";var e=require("@babel/runtime/helpers/extends"),t=require("three"),r=require("react"),n=require("@react-three/fiber"),a=require("react-merge-refs"),c=require("react-composer");function i(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var s=i(t),o=i(r);const u=new s.Matrix4,l=new s.Matrix4,m=[],f=new s.Mesh;class d extends s.Group{constructor(){super(),this.color=new s.Color("white"),this.instance={current:void 0},this.instanceKey={current:void 0}}get geometry(){var e;return null==(e=this.instance.current)?void 0:e.geometry}raycast(e,t){const r=this.instance.current;if(!r)return;if(!r.geometry||!r.material)return;f.geometry=r.geometry;const n=r.matrixWorld,a=r.userData.instances.indexOf(this.instanceKey);if(!(-1===a||a>r.count)){r.getMatrixAt(a,u),l.multiplyMatrices(n,u),f.matrixWorld=l,r.material instanceof s.Material?f.material.side=r.material.side:f.material.side=r.material[0].side,f.raycast(e,m);for(let e=0,r=m.length;e<r;e++){const r=m[e];r.instanceId=a,r.object=this,t.push(r)}m.length=0}}}const y=o.createContext(null),h=new s.Matrix4,g=new s.Matrix4,p=new s.Matrix4,x=new s.Vector3,M=new s.Quaternion,w=new s.Vector3,b=o.forwardRef((({context:t,children:r,...c},i)=>{o.useMemo((()=>n.extend({PositionMesh:d})),[]);const s=o.useRef(),{subscribe:u,getParent:l}=o.useContext(t||y);return o.useLayoutEffect((()=>u(s)),[]),o.createElement("positionMesh",e({instance:l(),instanceKey:s,ref:a([i,s])},c),r)})),v=o.forwardRef((({children:t,range:r,limit:c=1e3,frames:i=1/0,...u},l)=>{const[{context:m,instance:f}]=o.useState((()=>{const t=o.createContext(null);return{context:t,instance:o.forwardRef(((r,n)=>o.createElement(b,e({context:t},r,{ref:n}))))}})),d=o.useRef(null),[v,E]=o.useState([]),[[A,O]]=o.useState((()=>{const e=new Float32Array(16*c);for(let t=0;t<c;t++)p.identity().toArray(e,16*t);return[e,new Float32Array([...new Array(3*c)].map((()=>1)))]}));o.useEffect((()=>{d.current.instanceMatrix.needsUpdate=!0}));let j=0,R=0;n.useFrame((()=>{if(i===1/0||j<i){d.current.updateMatrix(),d.current.updateMatrixWorld(),h.copy(d.current.matrixWorld).invert(),R=Math.min(c,void 0!==r?r:c,v.length),d.current.count=R,d.current.instanceMatrix.updateRange.count=16*R,d.current.instanceColor.updateRange.count=3*R;for(let e=0;e<v.length;e++){const t=v[e].current;t.matrixWorld.decompose(x,M,w),g.compose(x,M,w).premultiply(h),g.toArray(A,16*e),d.current.instanceMatrix.needsUpdate=!0,t.color.toArray(O,3*e),d.current.instanceColor.needsUpdate=!0}j++}}));const C=o.useMemo((()=>({getParent:()=>d,subscribe:e=>(E((t=>[...t,e])),()=>E((t=>t.filter((t=>t.current!==e.current)))))})),[]);return o.createElement("instancedMesh",e({userData:{instances:v},matrixAutoUpdate:!1,ref:a([l,d]),args:[null,null,0],raycast:()=>null},u),o.createElement("instancedBufferAttribute",{attach:"instanceMatrix",count:A.length/16,array:A,itemSize:16,usage:s.DynamicDrawUsage}),o.createElement("instancedBufferAttribute",{attach:"instanceColor",count:O.length/3,array:O,itemSize:3,usage:s.DynamicDrawUsage}),"function"==typeof t?o.createElement(m.Provider,{value:C},t(f)):o.createElement(y.Provider,{value:C},t))})),E=o.forwardRef((function({meshes:t,children:r,...n},a){const i=Array.isArray(t);if(!i)for(const e of Object.keys(t))t[e].isMesh||delete t[e];return o.createElement("group",{ref:a},o.createElement(c,{components:(i?t:Object.values(t)).map((({geometry:t,material:r})=>o.createElement(v,e({key:t.uuid,geometry:t,material:r},n))))},(e=>i?r(...e):r(Object.keys(t).filter((e=>t[e].isMesh)).reduce(((t,r,n)=>({...t,[r]:e[n]})),{})))))}));exports.Instance=b,exports.Instances=v,exports.Merged=E;
