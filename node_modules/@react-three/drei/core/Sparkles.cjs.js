"use strict";var e=require("@babel/runtime/helpers/extends"),t=require("react"),r=require("three"),o=require("@react-three/fiber"),i=require("./shaderMaterial.cjs.js");function n(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var o=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,o.get?o:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var a=n(t),l=n(r);const s=i.shaderMaterial({time:0,pixelRatio:1}," uniform float pixelRatio;\n    uniform float time;\n    attribute float size;  \n    attribute float speed;  \n    attribute float opacity;\n    attribute vec3 noise;\n    attribute vec3 color;\n    varying vec3 vColor;\n    varying float vOpacity;\n    void main() {\n      vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n      modelPosition.y += sin(time * speed + modelPosition.x * noise.x * 100.0) * 0.2;\n      modelPosition.z += cos(time * speed + modelPosition.x * noise.y * 100.0) * 0.2;\n      modelPosition.x += cos(time * speed + modelPosition.x * noise.z * 100.0) * 0.2;\n      vec4 viewPosition = viewMatrix * modelPosition;\n      vec4 projectionPostion = projectionMatrix * viewPosition;\n      gl_Position = projectionPostion;\n      gl_PointSize = size * 25. * pixelRatio;\n      gl_PointSize *= (1.0 / - viewPosition.z);\n      vColor = color;\n      vOpacity = opacity;\n    }"," varying vec3 vColor;\n    varying float vOpacity;\n    void main() {\n      float distanceToCenter = distance(gl_PointCoord, vec2(0.5));\n      float strength = 0.05 / distanceToCenter - 0.1;\n      gl_FragColor = vec4(vColor, strength * vOpacity);\n      #include <tonemapping_fragment>\n      #include <encodings_fragment>\n    }"),c=e=>e&&e.constructor===Float32Array,u=e=>e instanceof l.Vector2||e instanceof l.Vector3||e instanceof l.Vector4,f=e=>Array.isArray(e)?e:u(e)?e.toArray():[e,e,e];function m(e,t,r){return a.useMemo((()=>{if(void 0!==t){if(c(t))return t;if(t instanceof l.Color){const r=Array.from({length:3*e},(()=>{return[(e=t).r,e.g,e.b];var e})).flat();return Float32Array.from(r)}if(u(t)||Array.isArray(t)){const r=Array.from({length:3*e},(()=>f(t))).flat();return Float32Array.from(r)}return Float32Array.from({length:e},(()=>t))}return Float32Array.from({length:e},r)}),[t])}const p=a.forwardRef((({noise:t=1,count:r=100,speed:i=1,opacity:n=1,scale:u=1,size:p,color:d,children:v,...b},y)=>{a.useMemo((()=>o.extend({SparklesImplMaterial:s})),[]);const g=a.useRef(null),h=o.useThree((e=>e.viewport.dpr)),A=a.useMemo((()=>Float32Array.from(Array.from({length:r},(()=>f(u).map(l.MathUtils.randFloatSpread))).flat())),[r,u]),P=m(r,p,Math.random),x=m(r,n),M=m(r,i),O=m(3*r,t),j=m(void 0===d?3*r:r,c(d)?d:new l.Color(d),(()=>1));return o.useFrame((e=>{g.current&&g.current.material&&(g.current.material.time=e.clock.elapsedTime)})),a.useImperativeHandle(y,(()=>g.current),[]),a.createElement("points",e({key:`particle-${r}-${JSON.stringify(u)}`},b,{ref:g}),a.createElement("bufferGeometry",null,a.createElement("bufferAttribute",{attach:"attributes-position",args:[A,3]}),a.createElement("bufferAttribute",{attach:"attributes-size",args:[P,1]}),a.createElement("bufferAttribute",{attach:"attributes-opacity",args:[x,1]}),a.createElement("bufferAttribute",{attach:"attributes-speed",args:[M,1]}),a.createElement("bufferAttribute",{attach:"attributes-color",args:[j,3]}),a.createElement("bufferAttribute",{attach:"attributes-noise",args:[O,3]})),v||a.createElement("sparklesImplMaterial",{transparent:!0,pixelRatio:h,depthWrite:!1}))}));exports.Sparkles=p;
