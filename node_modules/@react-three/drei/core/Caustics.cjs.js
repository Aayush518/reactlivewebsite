"use strict";var e=require("@babel/runtime/helpers/extends"),r=require("three"),t=require("react"),n=require("@react-three/fiber"),o=require("./useFBO.cjs.js"),i=require("./useHelper.cjs.js"),a=require("./shaderMaterial.cjs.js"),l=require("./Edges.cjs.js"),c=require("three-stdlib");function s(e){var r=Object.create(null);return e&&Object.keys(e).forEach((function(t){if("default"!==t){var n=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(r,t,n.get?n:{enumerable:!0,get:function(){return e[t]}})}})),r.default=e,Object.freeze(r)}var u=s(r),d=s(t);function m(e=u.FrontSide){const r={value:new u.Matrix4};return Object.assign(new u.MeshNormalMaterial({side:e}),{viewMatrix:r,onBeforeCompile:e=>{e.uniforms.viewMatrix=r,e.fragmentShader="vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n           return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n         }\n"+e.fragmentShader.replace("#include <normal_fragment_maps>","#include <normal_fragment_maps>\n           normal = inverseTransformDirection( normal, viewMatrix );\n")}})}const p=a.shaderMaterial({causticsTexture:null,causticsTextureB:null,color:new u.Color,lightProjMatrix:new u.Matrix4,lightViewMatrix:new u.Matrix4},"varying vec3 vWorldPosition;   \n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vec4 worldPosition = modelMatrix * vec4(position, 1.);\n     vWorldPosition = worldPosition.xyz;\n   }","varying vec3 vWorldPosition;\n  uniform vec3 color;\n  uniform sampler2D causticsTexture; \n  uniform sampler2D causticsTextureB; \n  uniform mat4 lightProjMatrix;\n  uniform mat4 lightViewMatrix;\n   void main() {\n    // Apply caustics  \n    vec4 lightSpacePos = lightProjMatrix * lightViewMatrix * vec4(vWorldPosition, 1.0);\n    lightSpacePos.xyz /= lightSpacePos.w;\n    lightSpacePos.xyz = lightSpacePos.xyz * 0.5 + 0.5; \n    vec3 front = texture2D(causticsTexture, lightSpacePos.xy).rgb;\n    vec3 back = texture2D(causticsTextureB, lightSpacePos.xy).rgb;\n    gl_FragColor = vec4((front + back) * color, 1.0);\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n   }"),v=a.shaderMaterial({cameraMatrixWorld:new u.Matrix4,cameraProjectionMatrixInv:new u.Matrix4,normalTexture:null,depthTexture:null,lightDir:new u.Vector3(0,1,0),lightPlaneNormal:new u.Vector3(0,1,0),lightPlaneConstant:0,near:.1,far:100,modelMatrix:new u.Matrix4,worldRadius:1/40,ior:1.1,bounces:0,resolution:1024,size:10,intensity:.5},"\n  varying vec2 vUv;\n  void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }","  \n  uniform mat4 cameraMatrixWorld;\n  uniform mat4 cameraProjectionMatrixInv;\n  uniform vec3 lightDir;\n  uniform vec3 lightPlaneNormal;\n  uniform float lightPlaneConstant;\n  uniform float near;\n  uniform float far;\n  uniform float time;\n  uniform float worldRadius;\n  uniform float resolution;\n  uniform float size;\n  uniform float intensity;\n  uniform float ior;\n  precision highp isampler2D;\n  precision highp usampler2D;\n  uniform sampler2D normalTexture;\n  uniform sampler2D depthTexture;\n  uniform float bounces;\n  varying vec2 vUv;\n  vec3 WorldPosFromDepth(float depth, vec2 coord) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n    vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;\n    // Perspective division\n    viewSpacePosition /= viewSpacePosition.w;\n    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\n    return worldSpacePosition.xyz;\n  }                  \n  float sdPlane( vec3 p, vec3 n, float h ) {\n    // n must be normalized\n    return dot(p,n) + h;\n  }\n  float planeIntersect( vec3 ro, vec3 rd, vec4 p ) {\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n  }\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 pos, vec3 normal, float ior, out vec3 rayOrigin, out vec3 rayDirection) {\n    rayOrigin = ro;\n    rayDirection = rd;\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\n    rayOrigin = pos + rayDirection * 0.1;\n    return rayDirection;\n  }\n  void main() {\n    // Each sample consists of random offset in the x and y direction\n    float caustic = 0.0;\n    float causticTexelSize = (1.0 / resolution) * size * 2.0;\n    float texelsNeeded = worldRadius / causticTexelSize;\n    float sampleRadius = texelsNeeded / resolution;\n    float sum = 0.0;\n    if (texture2D(depthTexture, vUv).x == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec2 offset1 = vec2(-0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset2 = vec2(-0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset3 = vec2(0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset4 = vec2(0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 uv1 = vUv + offset1 * sampleRadius;\n    vec2 uv2 = vUv + offset2 * sampleRadius;\n    vec2 uv3 = vUv + offset3 * sampleRadius;\n    vec2 uv4 = vUv + offset4 * sampleRadius;\n    vec3 normal1 = texture2D(normalTexture, uv1, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal2 = texture2D(normalTexture, uv2, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal3 = texture2D(normalTexture, uv3, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal4 = texture2D(normalTexture, uv4, -10.0).rgb * 2.0 - 1.0;\n    float depth1 = texture2D(depthTexture, uv1, -10.0).x;\n    float depth2 = texture2D(depthTexture, uv2, -10.0).x;\n    float depth3 = texture2D(depthTexture, uv3, -10.0).x;\n    float depth4 = texture2D(depthTexture, uv4, -10.0).x;\n    // Sanity check the depths\n    if (depth1 == 1.0 || depth2 == 1.0 || depth3 == 1.0 || depth4 == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec3 pos1 = WorldPosFromDepth(depth1, uv1);\n    vec3 pos2 = WorldPosFromDepth(depth2, uv2);\n    vec3 pos3 = WorldPosFromDepth(depth3, uv3);\n    vec3 pos4 = WorldPosFromDepth(depth4, uv4);\n    vec3 originPos1 = WorldPosFromDepth(0.0, uv1);\n    vec3 originPos2 = WorldPosFromDepth(0.0, uv2);\n    vec3 originPos3 = WorldPosFromDepth(0.0, uv3);\n    vec3 originPos4 = WorldPosFromDepth(0.0, uv4);\n    vec3 endPos1, endPos2, endPos3, endPos4;\n    vec3 endDir1, endDir2, endDir3, endDir4;\n    totalInternalReflection(originPos1, lightDir, pos1, normal1, ior, endPos1, endDir1);\n    totalInternalReflection(originPos2, lightDir, pos2, normal2, ior, endPos2, endDir2);\n    totalInternalReflection(originPos3, lightDir, pos3, normal3, ior, endPos3, endDir3);\n    totalInternalReflection(originPos4, lightDir, pos4, normal4, ior, endPos4, endDir4);\n    float lightPosArea = length(cross(originPos2 - originPos1, originPos3 - originPos1)) + length(cross(originPos3 - originPos1, originPos4 - originPos1));\n    float t1 = planeIntersect(endPos1, endDir1, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t2 = planeIntersect(endPos2, endDir2, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t3 = planeIntersect(endPos3, endDir3, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t4 = planeIntersect(endPos4, endDir4, vec4(lightPlaneNormal, lightPlaneConstant));\n    vec3 finalPos1 = endPos1 + endDir1 * t1;\n    vec3 finalPos2 = endPos2 + endDir2 * t2;\n    vec3 finalPos3 = endPos3 + endDir3 * t3;\n    vec3 finalPos4 = endPos4 + endDir4 * t4;\n    float finalArea = length(cross(finalPos2 - finalPos1, finalPos3 - finalPos1)) + length(cross(finalPos3 - finalPos1, finalPos4 - finalPos1));\n    caustic += intensity * (lightPosArea / finalArea);\n    // Calculate the area of the triangle in light spaces\n    gl_FragColor = vec4(vec3(max(caustic, 0.0)), 1.0);\n  }"),f={depth:!0,minFilter:u.LinearFilter,magFilter:u.LinearFilter,type:u.UnsignedByteType},x={minFilter:u.LinearMipmapLinearFilter,magFilter:u.LinearFilter,type:u.FloatType,generateMipmaps:!0},h=d.forwardRef((({debug:r,children:t,frames:a=1,ior:s=1.1,color:h="white",causticsOnly:g=!1,backside:P=!1,backsideIOR:y=1.1,worldRadius:M=.3125,intensity:D=.05,resolution:w=2024,lightSource:T=[5,5,5],...S},F)=>{n.extend({CausticsProjectionMaterial:p});const b=d.useRef(null),j=d.useRef(null),z=d.useRef(null),W=d.useRef(null),R=n.useThree((e=>e.gl)),I=i.useHelper(r&&j,u.CameraHelper),C=o.useFBO(w,w,f),O=o.useFBO(w,w,f),V=o.useFBO(w,w,x),B=o.useFBO(w,w,x),[E]=d.useState((()=>m())),[_]=d.useState((()=>m(u.BackSide))),[A]=d.useState((()=>new v)),[N]=d.useState((()=>new c.FullScreenQuad(A)));d.useLayoutEffect((()=>{b.current.updateWorldMatrix(!1,!0)}));let k=0;const q=new u.Vector3,U=new u.Frustum,L=new u.Matrix4,H=new u.Plane,G=new u.Vector3,Q=new u.Vector3,J=new u.Box3,K=new u.Vector3,X=[],Y=[],Z=[],$=[],ee=new u.Vector3;for(let e=0;e<8;e++)X.push(new u.Vector3),Y.push(new u.Vector3),Z.push(new u.Vector3),$.push(new u.Vector3);return n.useFrame((()=>{if(a===1/0||k++<a){var e,t;Array.isArray(T)?G.fromArray(T).normalize():G.copy(b.current.worldToLocal(T.current.getWorldPosition(q)).normalize()),Q.copy(G).multiplyScalar(-1),null==(e=z.current.parent)||e.matrixWorld.identity(),J.setFromObject(z.current,!0),X[0].set(J.min.x,J.min.y,J.min.z),X[1].set(J.min.x,J.min.y,J.max.z),X[2].set(J.min.x,J.max.y,J.min.z),X[3].set(J.min.x,J.max.y,J.max.z),X[4].set(J.max.x,J.min.y,J.min.z),X[5].set(J.max.x,J.min.y,J.max.z),X[6].set(J.max.x,J.max.y,J.min.z),X[7].set(J.max.x,J.max.y,J.max.z);for(let e=0;e<8;e++)Y[e].copy(X[e]);J.getCenter(K),X.map((e=>e.sub(K)));const n=H.set(Q,0);X.map(((e,r)=>n.projectPoint(e,Z[r])));const o=Z.reduce(((e,r)=>e.add(r)),q.set(0,0,0)).divideScalar(Z.length),i=Z.map((e=>e.distanceTo(o))).reduce(((e,r)=>Math.max(e,r))),a=X.map((e=>e.dot(G))).reduce(((e,r)=>Math.max(e,r)));j.current.position.copy(ee.copy(G).multiplyScalar(a).add(K)),j.current.lookAt(z.current.localToWorld(K));const l=L.lookAt(j.current.position,K,q.set(0,1,0));j.current.left=-i,j.current.right=i,j.current.top=i,j.current.bottom=-i;const c=q.set(0,i,0).applyMatrix4(l),u=(j.current.position.y+c.y)/G.y;j.current.near=.1,j.current.far=u,j.current.updateProjectionMatrix(),j.current.updateMatrixWorld();const d=Y.map(((e,r)=>e.add($[r].copy(G).multiplyScalar(-e.y/G.y)))),m=d.reduce(((e,r)=>e.add(r)),q.set(0,0,0)).divideScalar(d.length),p=2*d.map((e=>Math.hypot(e.x-m.x,e.z-m.z))).reduce(((e,r)=>Math.max(e,r)));W.current.scale.setScalar(p),W.current.position.copy(m),r&&(null==(t=I.current)||t.update()),_.viewMatrix.value=E.viewMatrix.value=j.current.matrixWorldInverse;const v=U.setFromProjectionMatrix(L.multiplyMatrices(j.current.projectionMatrix,j.current.matrixWorldInverse)).planes[4];A.cameraMatrixWorld=j.current.matrixWorld,A.cameraProjectionMatrixInv=j.current.projectionMatrixInverse,A.lightDir=Q,A.lightPlaneNormal=v.normal,A.lightPlaneConstant=v.constant,A.near=j.current.near,A.far=j.current.far,A.resolution=w,A.size=i,A.intensity=D,A.worldRadius=M,z.current.visible=!0,R.setRenderTarget(C),R.clear(),z.current.overrideMaterial=E,R.render(z.current,j.current),R.setRenderTarget(O),R.clear(),P&&(z.current.overrideMaterial=_,R.render(z.current,j.current)),z.current.overrideMaterial=null,A.ior=s,W.current.material.lightProjMatrix=j.current.projectionMatrix,W.current.material.lightViewMatrix=j.current.matrixWorldInverse,A.normalTexture=C.texture,A.depthTexture=C.depthTexture,R.setRenderTarget(V),R.clear(),N.render(R),A.ior=y,A.normalTexture=O.texture,A.depthTexture=O.depthTexture,R.setRenderTarget(B),R.clear(),P&&N.render(R),R.setRenderTarget(null),g&&(z.current.visible=!1)}})),d.useImperativeHandle(F,(()=>b.current),[]),d.createElement("group",e({ref:b},S),d.createElement("scene",{ref:z},d.createElement("orthographicCamera",{ref:j,up:[0,1,0]}),t),d.createElement("mesh",{renderOrder:2,ref:W,"rotation-x":-Math.PI/2},d.createElement("planeGeometry",null),d.createElement("causticsProjectionMaterial",{transparent:!0,color:h,causticsTexture:V.texture,causticsTextureB:B.texture,blending:u.CustomBlending,blendSrc:u.OneFactor,blendDst:u.SrcAlphaFactor,depthWrite:!1}),r&&d.createElement(l.Edges,null,d.createElement("lineBasicMaterial",{color:"#ffff00",toneMapped:!1}))))}));exports.Caustics=h;
