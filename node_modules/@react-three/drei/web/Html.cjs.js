"use strict";var e=require("@babel/runtime/helpers/extends"),t=require("react"),r=require("react-dom/client"),n=require("three"),o=require("@react-three/fiber");function i(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var s=i(t),a=i(r);const c=new n.Vector3,l=new n.Vector3,u=new n.Vector3;function d(e,t,r){const n=c.setFromMatrixPosition(e.matrixWorld);n.project(t);const o=r.width/2,i=r.height/2;return[n.x*o+o,-n.y*i+i]}const m=e=>Math.abs(e)<1e-10?0:e;function f(e,t,r=""){let n="matrix3d(";for(let r=0;16!==r;r++)n+=m(t[r]*e.elements[r])+(15!==r?",":")");return r+n}const h=(p=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],e=>f(e,p));var p;const x=(e,t)=>{return f(e,[1/(r=t),1/r,1/r,1,-1/r,-1/r,-1/r,-1,1/r,1/r,1/r,1,1,1,1,1],"translate(-50%,-50%)");var r};const v=s.forwardRef((({children:t,eps:r=.001,style:i,className:f,prepend:p,center:v,fullscreen:y,portal:g,distanceFactor:M,sprite:P=!1,transform:b=!1,occlude:w,onOcclude:E,castShadow:W,receiveShadow:S,material:$,geometry:z,zIndexRange:R=[16777271,0],calculatePosition:j=d,as:F="div",wrapperClass:O,pointerEvents:C="auto",...T},I)=>{const{gl:A,camera:k,scene:H,size:N,raycaster:q,events:V,viewport:L}=o.useThree(),[D]=s.useState((()=>document.createElement(F))),_=s.useRef(),G=s.useRef(null),Z=s.useRef(0),B=s.useRef([0,0]),J=s.useRef(null),K=s.useRef(null),Q=(null==g?void 0:g.current)||V.connected||A.domElement.parentNode,U=s.useRef(null),X=s.useRef(!1),Y=s.useMemo((()=>w&&"blending"!==w||Array.isArray(w)&&w.length&&function(e){return e&&"object"==typeof e&&"current"in e}(w[0])),[w]);s.useLayoutEffect((()=>{const e=A.domElement;w&&"blending"===w?(e.style.zIndex=`${Math.floor(R[0]/2)}`,e.style.position="absolute",e.style.pointerEvents="none"):(e.style.zIndex=null,e.style.position=null,e.style.pointerEvents=null)}),[w]),s.useLayoutEffect((()=>{if(G.current){const e=_.current=a.createRoot(D);if(H.updateMatrixWorld(),b)D.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const e=j(G.current,k,N);D.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${e[0]}px,${e[1]}px,0);transform-origin:0 0;`}return Q&&(p?Q.prepend(D):Q.appendChild(D)),()=>{Q&&Q.removeChild(D),e.unmount()}}}),[Q,b]),s.useLayoutEffect((()=>{O&&(D.className=O)}),[O]);const ee=s.useMemo((()=>b?{position:"absolute",top:0,left:0,width:N.width,height:N.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:v?"translate3d(-50%,-50%,0)":"none",...y&&{top:-N.height/2,left:-N.width/2,width:N.width,height:N.height},...i}),[i,v,y,N,b]),te=s.useMemo((()=>({position:"absolute",pointerEvents:C})),[C]);s.useLayoutEffect((()=>{var e,r;(X.current=!1,b)?null==(e=_.current)||e.render(s.createElement("div",{ref:J,style:ee},s.createElement("div",{ref:K,style:te},s.createElement("div",{ref:I,className:f,style:i,children:t})))):null==(r=_.current)||r.render(s.createElement("div",{ref:I,style:ee,className:f,children:t}))}));const re=s.useRef(!0);o.useFrame((e=>{if(G.current){k.updateMatrixWorld(),G.current.updateWorldMatrix(!0,!1);const e=b?B.current:j(G.current,k,N);if(b||Math.abs(Z.current-k.zoom)>r||Math.abs(B.current[0]-e[0])>r||Math.abs(B.current[1]-e[1])>r){const t=function(e,t){const r=c.setFromMatrixPosition(e.matrixWorld),n=l.setFromMatrixPosition(t.matrixWorld),o=r.sub(n),i=t.getWorldDirection(u);return o.angleTo(i)>Math.PI/2}(G.current,k);let r=!1;Y&&("blending"!==w?r=[H]:Array.isArray(w)&&(r=w.map((e=>e.current))));const o=re.current;if(r){const e=function(e,t,r,n){const o=c.setFromMatrixPosition(e.matrixWorld),i=o.clone();i.project(t),r.setFromCamera(i,t);const s=r.intersectObjects(n,!0);if(s.length){const e=s[0].distance;return o.distanceTo(r.ray.origin)<e}return!0}(G.current,k,q,r);re.current=e&&!t}else re.current=!t;o!==re.current&&(E?E(!re.current):D.style.display=re.current?"block":"none");const i=Math.floor(R[0]/2),s=w?Y?[R[0],i]:[i-1,0]:R;if(D.style.zIndex=`${function(e,t,r){if(t instanceof n.PerspectiveCamera||t instanceof n.OrthographicCamera){const n=c.setFromMatrixPosition(e.matrixWorld),o=l.setFromMatrixPosition(t.matrixWorld),i=n.distanceTo(o),s=(r[1]-r[0])/(t.far-t.near),a=r[1]-s*t.far;return Math.round(s*i+a)}}(G.current,k,s)}`,b){const[e,t]=[N.width/2,N.height/2],r=k.projectionMatrix.elements[5]*t,{isOrthographicCamera:n,top:o,left:i,bottom:s,right:a}=k,c=h(k.matrixWorldInverse),l=n?`scale(${r})translate(${m(-(a+i)/2)}px,${m((o+s)/2)}px)`:`translateZ(${r}px)`;let u=G.current.matrixWorld;P&&(u=k.matrixWorldInverse.clone().transpose().copyPosition(u).scale(G.current.scale),u.elements[3]=u.elements[7]=u.elements[11]=0,u.elements[15]=1),D.style.width=N.width+"px",D.style.height=N.height+"px",D.style.perspective=n?"":`${r}px`,J.current&&K.current&&(J.current.style.transform=`${l}${c}translate(${e}px,${t}px)`,K.current.style.transform=x(u,1/((M||10)/400)))}else{const t=void 0===M?1:function(e,t){if(t instanceof n.OrthographicCamera)return t.zoom;if(t instanceof n.PerspectiveCamera){const r=c.setFromMatrixPosition(e.matrixWorld),n=l.setFromMatrixPosition(t.matrixWorld),o=t.fov*Math.PI/180,i=r.distanceTo(n);return 1/(2*Math.tan(o/2)*i)}return 1}(G.current,k)*M;D.style.transform=`translate3d(${e[0]}px,${e[1]}px,0) scale(${t})`}B.current=e,Z.current=k.zoom}}if(!Y&&U.current&&!X.current)if(b){if(J.current){const e=J.current.children[0];if(null!=e&&e.clientWidth&&null!=e&&e.clientHeight){const{isOrthographicCamera:t}=k;if(t||z)T.scale&&(Array.isArray(T.scale)?T.scale instanceof n.Vector3?U.current.scale.copy(T.scale.clone().divideScalar(1)):U.current.scale.set(1/T.scale[0],1/T.scale[1],1/T.scale[2]):U.current.scale.setScalar(1/T.scale));else{const t=(M||10)/400,r=e.clientWidth*t,n=e.clientHeight*t;U.current.scale.set(r,n,1)}X.current=!0}}}else{const t=D.children[0];if(null!=t&&t.clientWidth&&null!=t&&t.clientHeight){const e=1/L.factor,r=t.clientWidth*e,n=t.clientHeight*e;U.current.scale.set(r,n,1),X.current=!0}U.current.lookAt(e.camera.position)}}));const ne=s.useMemo((()=>({vertexShader:b?void 0:'\n          /*\n            This shader is from the THREE\'s SpriteMaterial.\n            We need to turn the backing plane into a Sprite\n            (make it always face the camera) if "transfrom" \n            is false. \n          */\n          #include <common>\n\n          void main() {\n            vec2 center = vec2(0., 1.);\n            float rotation = 0.0;\n            \n            // This is somewhat arbitrary, but it seems to work well\n            // Need to figure out how to derive this dynamically if it even matters\n            float size = 0.03;\n\n            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n            vec2 scale;\n            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n            bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n            if ( isPerspective ) scale *= - mvPosition.z;\n\n            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\n            vec2 rotatedPosition;\n            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n            mvPosition.xy += rotatedPosition;\n\n            gl_Position = projectionMatrix * mvPosition;\n          }\n      ',fragmentShader:"\n        void main() {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      "})),[b]);return s.createElement("group",e({},T,{ref:G}),w&&!Y&&s.createElement("mesh",{castShadow:W,receiveShadow:S,ref:U},z||s.createElement("planeGeometry",null),$||s.createElement("shaderMaterial",{side:n.DoubleSide,vertexShader:ne.vertexShader,fragmentShader:ne.fragmentShader})))}));exports.Html=v;
